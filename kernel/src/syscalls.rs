use crate::println;

// register for address of syscall handler
const MSR_STAR: usize = 0xc0000081;
const MSR_LSTAR: usize = 0xc0000082;

pub unsafe fn init_syscalls() {
    let handler_addr = handle_syscall as *const () as u64;
    // write handler address to AMD's MSR_LSTAR register
    asm!("\
    mov rdx, rax
    shr rdx, 32
    wrmsr" :: "{rax}"(handler_addr), "{rcx}"(MSR_LSTAR) : "rdx" : "intel", "volatile");
}

fn handle_syscall() {
    println!("FUCK YEAH SYSCALLS");
}

/* BEFORE SYSCALL

RAX=000000000000002b RBX=000000000000002b RCX=000000000019f000 RDX=0000000000000023
RSI=0000000000801000 RDI=00000000004000b0 RBP=0000000000000023 RSP=0000000000801000
R8 =000ffffffffff000 R9 =0000000000000002 R10=00000000c01adaf4 R11=0000000000000025
R12=00000000c0000000 R13=00000000004000b0 R14=00000000c01aef1c R15=00000000004d3000
RIP=00000000004000b0 RFL=00000206 [-----P-] CPL=3 II=0 A20=1 SMM=0 HLT=0
ES =0000 0000000000000000 00000000 00000000
CS =0023 0000000000000000 00000000 0020f800 DPL=3 CS64 [---]
SS =002b 0000000000000000 00000000 0000f300 DPL=3 DS   [-WA]
DS =002b 0000000000000000 00000000 0000f300 DPL=3 DS   [-WA]
FS =0000 0000000000000000 00000000 00000000
GS =0000 0000000000000000 00000000 00000000


AFTER SYSCALL


RAX=000000000000002b RBX=000000000000002b RCX=00000000004000b2 RDX=0000000000000023
RSI=0000000000801000 RDI=00000000004000b0 RBP=0000000000000023 RSP=0000000000801000
R8 =000ffffffffff000 R9 =0000000000000002 R10=00000000c01adaf4 R11=0000000000000206
R12=00000000c0000000 R13=00000000004000b0 R14=00000000c01aef1c R15=00000000004d3000
RIP=00000000c011cb50 RFL=00000202 [-------] CPL=0 II=0 A20=1 SMM=0 HLT=0
ES =0000 0000000000000000 00000000 00000000
CS =0000 0000000000000000 ffffffff 00a09b00 DPL=0 CS64 [-RA]
SS =0008 0000000000000000 ffffffff 00c09300 DPL=0 DS   [-WA]
DS =002b 0000000000000000 00000000 0000f300 DPL=3 DS   [-WA]
FS =0000 0000000000000000 00000000 00000000
GS =0000 0000000000000000 00000000 00000000
*/
